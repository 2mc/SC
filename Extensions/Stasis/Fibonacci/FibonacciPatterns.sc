/* IZ 100520

Creating patterns that will send the structure of the fibonacci-tree 
via OSC using automatically generated messages and arguments that reflect the structure of the tree. 

In this version, the values generated by current = current + 1 are not used. 
Other things could be substituted as contents of the leaves. 

f = FibPat(5);
p = f.pattern.asStream;
p.next;
*/

FibPat {
	var <iterations = 3;
	var >startBranch;		// function to evaluate when a branch starts
	var >endBranch;		// function to evaluate when a branch ends
	var <ascendingTree;	// An array holding the entire structure of the generated fibonacci tree in ascending order
						// smaller branches first
	var <descendingTree;	// An array holding the entire structure of the generated fibonacci tree in descending order
						// larger branches first
	var <pattern;			// The pattern that plays the tree

	*new { | iterations = 3, startBranch, endBranch |
		^this.newCopyArgs(iterations,
			startBranch ?? {{ | label, branch |
				format("start %, %", label, branch.asArray.flat.size).postln;
			}},
			endBranch ?? {{ | label |
				format("end %", label).postln;
			}}
		).init;
	}

	init {
		ascendingTree = this.makeAscendingTree;
		descendingTree = this.makeDescendingTree;
		pattern = this.makePattern;
	}
	
	makeAscendingTree {
		^{ | n = 1, prev = 1, current = 1 |
			var next;
			n do: {
				next = [prev, current + 1];
				prev = current;
				current = next;
			};
			current;
		}.(iterations)
	}

	makeDescendingTree {
		^{ | n = 1, prev = 1, current = 1 |
			var next;
			n do: {
				next = [current + 1, prev];
				prev = current;
				current = next;
			};
			current;
		}.(iterations)		
	}

	makePattern { | tree |
		var func;
		tree = tree ? ascendingTree;
		func = { | tree, label = "" |
			this.startBranch(label, tree);
			if (tree.size == 0) {
				this.yield;
			}{
				thisFunction.(tree[0], label ++ "A");
				thisFunction.(tree[1], label ++ "B");	 
			};
			this.endBranch(label);
		};
		^Prout({ func.(tree) });
	}

	
	startBranch { | label, branch |
		startBranch.(label, branch)
	}

	endBranch { | label |
		endBranch.(label);
	}

}