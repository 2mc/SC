/* IZ 100520

Creating patterns that will send the structure of the fibonacci-tree
via OSC using automatically generated messages and arguments that reflect the structure of the tree. 

In this version, the values generated by current = current + 1 are not used. 
Other things could be substituted as contents of the leaves. 

f = FibPat(5);
p = f.pattern.asStream;
p.next;
f.play

Pbind(\degree, Pseq([2 + FibPat(Fib.ascending(10)).pattern, 1 + FibPat(Fib.descending(10)).pattern], 1), \dur, 0.1).play;
(
Pbind(
	\type, \pause,
	\degree, Pseq([2 + FibPat(Fib.ascending(10)).pattern, 1 + FibPat(Fib.descending(10)).pattern], 1),
	\dur, 0.1
).play;
)

(
Ppar([
	Pbind(\degree, FibPat(Fib.ascending(10)).pattern, \dur, 0.1), 
	Pbind(\degree, 10 + FibPat(Fib.descending(10)).pattern, \dur, 0.1)
]).play;
)

FibPat.new.play;

Fib.ascending(5);
.play;

*/

Fib {	// generates fibonacci trees
	
	*ascending { | n = 3 | ^this.new.ascending(n) }
	ascending { | n = 3 |
		^{ | n = 1, prev = 1, current = 1 |
			var next;
			n do: {
				next = [prev, current + 1];
				prev = current;
				current = next;
			};
			current;
		}.(n)
	}
	*descending { | n = 3 | ^this.new.descending(n) }
	descending { | n = 3 |
		^{ | n = 1, prev = 1, current = 1 |
			var next;
			n do: {
				next = [current + 1, prev];
				prev = current;
				current = next;
			};
			current;
		}.(n)
	}
}


FibPat {	// creates patterns for playing fibonacci trees
	var <>tree;
	
	*new { | tree |
		^this.newCopyArgs(tree ?? { Fib.ascending });
	}

	pattern { | startFunc, endFunc |
		var func;
		startFunc = startFunc ?? {{ | label, branch | this.startBranch(label.branch) }};
		endFunc = endFunc ?? {{ | label | this.endBranch(label) }};
		func = { | tree, label = "" |
			this.startBranch(label, tree);
			if (tree.size == 0) {
				tree.yield;
			}{
				thisFunction.(tree[0], label ++ "A");
				thisFunction.(tree[1], label ++ "B");	 
			};
			this.endBranch(label);
		};
		^Prout({ func.(tree) });
	}

	startBranch { | label, branch |
		format("start %, %", label, branch.asArray.flat.size).postln;
	}

	endBranch { | label |
		format("end %", label).postln;
	}
	
	play {
		var stream;
		stream = this.pattern.asStream;
		while { stream.next.notNil } { "xxx" /* empty function would crash supercollider */ };
	}
	
}

