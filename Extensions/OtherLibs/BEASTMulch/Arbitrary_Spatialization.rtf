{\rtf1\mac\ansicpg10000\cocoartf824\cocoasubrtf420
{\fonttbl\f0\fnil\fcharset77 Monaco;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;\red0\green0\blue191;\red0\green115\blue0;
\red191\green0\blue0;}
\deftab1134
\pard\pardeftab1134\sb60\ql\qnatural

\f0\fs32 \cf2 Arbitrary Spatialisation
\fs18 \
\

\fs22 Depending on the project you are working on, you may want to use a different kind of spatialization, considering the setup of the speakers that you have and the content of your work. As an example, for the dance theatre piece 'Schwelle' (Baalman et al., 2007; http://www.schwelle.org), a setup was used with an inner space and an outer space. The inner space was created by four speakers (two stereo pairs) surrounding the stage, the outer space by speakers behind and above the audience. Various sound movements were defined within this space.\
\pard\pardeftab1134\ql\qnatural
\cf2 	For this we created one SynthDef for the spatialization mix (see the class \ul SchwelleSurround\ulnone ):\

\fs18 	\
s = \cf3 Server\cf2 .local.boot;\
\
(\
\cf3 SynthDef\cf2 ( \cf4 \\schwellesurround\cf2 , \{\
  \cf3 arg\cf2  out=0, in=0, amp=1, lag=1, lagmid=0.1, lagtop=0.1, lagdir=0.1, gate=1;\
  \cf3 var\cf2  envcut, inputs, dir, mid, top, ampsmid, ampsdir, ampstop;\
\
  ampsdir = \cf3 Control\cf2 .names([\cf4 \\ampsdir\cf2 ]).kr( \cf3 Array\cf2 .fill(8, 1.0 ));\
  ampsmid = \cf3 Control\cf2 .names([\cf4 \\ampsmid\cf2 ]).kr( \cf3 Array\cf2 .fill(4, 1.0 ));\
  ampstop = \cf3 Control\cf2 .names([\cf4 \\ampstop\cf2 ]).kr( \cf3 Array\cf2 .fill(4, 1.0 ));\
\
  inputs = \cf3 In\cf2 .ar( in, 8 );\
\
  dir = inputs * ampsdir.lag(lagdir);\
  dir[4] = dir[4] + (ampsmid[0].lag(lagmid) * inputs[0]) + (ampsmid[1].lag(lagmid) * inputs[1]);\
  dir[5] = dir[5] + (ampsmid[2].lag(lagmid) * inputs[2]) + (ampsmid[3].lag(lagmid) * inputs[3]);\
\
  dir[6] = dir[6] + (ampstop[2].lag(lagtop) * inputs[2]) + (ampstop[3].lag(lagtop) * inputs[3]);\
  dir[7] = dir[7] + (ampstop[0].lag(lagtop) * inputs[0]) + (ampstop[1].lag(lagtop) * inputs[1]);\
\
  envcut = \cf3 EnvGen\cf2 .kr( \cf3 Env\cf2 .cutoff(1,1,4), gate, doneAction: 2 );\
\
  \cf3 Out\cf2 .ar( out, dir * amp.lag(lag) * envcut );\
\}).send(s);\
)\
\
\pard\pardeftab1134\sb60\ql\qnatural
\cf2 	
\fs22 So there are 8 channels, of which the first four are surrounding channels (behind the audience), channels 4 and 5 go to the left and right of the stereo pairs surrounding the stage, and 6 and 7 to two speakers above the stage. ampsdir, ampsmid and ampstop are arrays determining the level of signal routed to the speakers for direct input to output (no mixing), mixing into the stage speakers, and into the top speakers, respectively.\
\pard\pardeftab1134\ql\qnatural
\cf2 	Then there are a number of control synthdefs which create various movements for the sound:
\fs18 \
\
(\
\cf5 // sound from the surround channels make a breathing movement to the middle speakers\cf2 \
\cf3 SynthDef\cf2 ( \cf4 \\surroundbreathmid\cf2 , \{ \cf3 arg\cf2  out=0, freq=1, mul=0.5, add=0.5;\
  \cf3 var\cf2  phases;\
  phases = \cf3 Control\cf2 .names([\cf4 \\phases\cf2 ]).kr( \cf3 Array\cf2 .fill(4, 0.5 ));\
  \cf3 Out\cf2 .kr( out, \cf3 SinOsc\cf2 .kr( freq, phases, mul, add ) );\
\}).send(s);\
\
\cf5 // sound moves like to mid or top speakers with attack time, and return with decay time\cf2 \
\cf3 SynthDef\cf2 ( \cf4 \\surroundmove\cf2 , \{ \cf3 arg\cf2  out=0, ts=1, attack=0.5, decay = 0.5;\
   \cf3 Out\cf2 .kr( out, \cf3 Array\cf2 .fill( 4, \cf3 EnvGen\cf2 .kr( \cf3 Env\cf2 .perc( attack, decay ), timeScale: ts, doneAction: 2 ) ) );\
\}).send(s);\
\
\cf5 // sound makes random "percussive" movements\cf2 \
\cf3 SynthDef\cf2 ( \cf4 \\surroundrandom\cf2 , \{ \cf3 arg\cf2  out=0, rate=1, ts=1, attack=0.5, decay = 0.5;\
   \cf3 Out\cf2 .kr( out, \cf3 Array\cf2 .fill( 4, \{ \cf3 EnvGen\cf2 .kr( \cf3 Env\cf2 .perc( attack, decay ), \cf3 Dust\cf2 .kr( rate ), timeScale: ts ) \} ) );\
\}).send(s);\
\
\cf5 // sound moves from the top to all speakers\cf2 \
\cf3 SynthDef\cf2 ( \cf4 \\surroundtoptoall\cf2 , \{ \cf3 arg\cf2  outdir=0, outmid=0, outtop=0, dur=5.0;\
   \cf3 var\cf2  fade;\
   fade = \cf3 XLine\cf2 .kr( 0.00001, 1, dur, doneAction: 2 );\
   \cf3 Out\cf2 .kr( outtop, \cf3 Array\cf2 .fill( 4, 0.5 ) );\
   \cf3 Out\cf2 .kr( outmid, \cf3 Array\cf2 .fill( 4, fade ) );\
   \cf3 Out\cf2 .kr( outdir, \cf3 Array\cf2 .fill( 4, fade ) );\
\}).send(s);\
)\
\
\pard\pardeftab1134\sb60\ql\qnatural
\cf2 	
\fs22 Then a basic infrastructure is set up with control busses mapped to the control arguments of the surround synth (see the SchwelleSurround::init):
\fs18 \
\pard\pardeftab1134\ql\qnatural
\cf2 \
controlmid = \cf3 Bus\cf2 .control( server, 4 );\
controltop = \cf3 Bus\cf2 .control( server, 4 );\
controldir = \cf3 Bus\cf2 .control( server, 8 );\
controlgroup = \cf3 Group\cf2 .new( group, \cf4 \\addToTail\cf2  ); \
\
bus = \cf3 Bus\cf2 .audio( server, 8 ); \cf5 // these are the busses of the room mix for the input to the surround mix\cf2 \
outbus = \cf3 Bus\cf2 .new(\cf4 \\audio\cf2 ,0,8);\
\
synth = \cf3 Synth\cf2 .new( \cf4 \\schwellesurround\cf2 , [\cf4 \\out\cf2 ,outbus.index,\cf4 \\in\cf2 ,bus.index], group,\cf4 \\addToTail\cf2  );\
\
synth.busMap( \cf4 \\ampsdir\cf2 , controldir );\
synth.busMap( \cf4 \\ampsmid\cf2 , controlmid );\
synth.busMap( \cf4 \\ampstop\cf2 , controltop );\
\
\pard\pardeftab1134\sb60\ql\qnatural

\fs22 \cf2 	Now a movement of the sound can be created by writing values to the busses with one of the control synths. For example, to make a movement to the top:
\fs18 \
\pard\pardeftab1134\ql\qnatural
\cf2 \
\cf3 Synth\cf2 .new( \cf4 \\surroundmove\cf2 , [\cf4 \\out\cf2 , controltop.index, \cf4 \\attack\cf2 , 0.99, \cf4 \\decay\cf2 , 0.01, \cf4 \\ts\cf2 , 5], controlgroup, \cf4 \\addToTail\cf2  );\
\
\pard\pardeftab1134\sb60\ql\qnatural
\cf2 	
\fs22 This is just an example, of how you can approach creating spatialization for your piece, and how you could set up a framework for dealing with it. You can assign any algorithm to determine to which speaker a sound is routed and at what amplitude; this is your compositional freedom.\
	\
To use the SchwelleSurround class:\
\
\cf5 // set up the main structure:\cf2 \
~output = \cf3 Bus\cf2 .new( \cf4 \\audio\cf2 , 0, 8 );\
~group = \cf3 Group\cf2 .new;\
\
\cf5 // create an instance of SchwelleSurround:\cf2 \
a = \cf3 SchwelleSurround\cf2 .new( ~output, ~group, s );\
\
\cf5 // start the synth:\cf2 \
a.start;\
\
\cf5 // Then create some Synths that output to a.bus.\cf2 \
\
\cf5 // and make movements using:\cf2 \
\
\cf5 // to the top:\cf2 \
a.movetop( 0.99, 0.01, 4 ); \cf5 // attack, decay, timescale\cf2 \
\
\cf5 // to the middle:\cf2 \
a.movemid( 0.99, 0.01, 4 ); \cf5 // attack, decay, timescale\cf2 \
\
\cf5 // breathing from outer speakers to middle speakers\cf2 \
a.breathmid( 0.1, [0 0 0 0], 0.5, 0.5 ); \cf5 // frequency, start phases, mul, add\cf2 \
\
\cf5 // random movement through the room\cf2 \
a.randomroom( 1, 0.99, 0.01, 1 ); \cf5 // rate, attack, decay, timescale\cf2 \
\
\cf5 // random movement to the top\cf2 \
a.randomtop( 1, 0.99, 0.01, 1 ); \cf5 // rate, attack, decay, timescale\cf2 \
\
\cf5 // from the top to all speakers:\cf2 \
a.toptoall( 3 ); \cf5 // duration\cf2 \
\
\cf5 // stop the movement:\cf2 \
a.stopmove;\
}