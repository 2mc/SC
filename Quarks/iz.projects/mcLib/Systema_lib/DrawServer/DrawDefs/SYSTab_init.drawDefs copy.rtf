{\rtf1\ansi\ansicpg1252\cocoartf1038\cocoasubrtf350
{\fonttbl\f0\fnil\fcharset0 Monaco;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;\red0\green0\blue191;\red96\green96\blue96;
\red191\green0\blue0;\red0\green115\blue0;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural

\f0\fs18 \cf2 if (\cf3 this\cf2 .isLog(2)) \{ (\cf4 "\\n\\n"\cf2  + \cf3 thisProcess\cf2 .nowExecutingPath.basename + \cf4 "\\n"\cf2 ).postln; \};\
\cf5 /*\
DrawDef.all.keys\
*/\cf2 \
\
(\
\cf3 DrawDef\cf2 (\cf6 \\SYSTab_init\cf2 ,\
	\{\cf3 |node, self, sysTab|\cf2 \
		\cf3 var\cf2  drawSever = node.tree.server;\
		\cf3 var\cf2  envir = drawSever.drawEnvir, pE = envir.parent;\
		\cf3 var\cf2  rCount, qCount, aCount;\
	\
		pE.putAll(self.envir);\
		\
		drawSever.scaleMode_(pE.scaleMode); \cf5 //also updates back into drawEnvir, but ok\cf2 \
		pE.scale !? \{ drawSever.actionView.scale_(pE.scale, \cf3 false\cf2 ) \}; \cf5 //show next frame only \cf2 \
		pE.move !? \{ drawSever.actionView.oneShotRefreshAction = \{\
			drawSever.actionView.move_(pE.move, \cf3 false\cf2 ) \}\};  \cf5 //do at end of first frame\cf2 \
		\
		\cf5 // keyActions\cf2 \
		rCount = pE.refMode; qCount = pE.quantMode; aCount = pE.anchorMode;\
		\
		drawSever.addActionChar($k, \{\cf3 |down, repeat|\cf2  if (down && repeat.not) \{\
			pE.keysOn = pE.keysOn.not \}; \cf3 true\cf2  \});\
		drawSever.addActionChar($o, \{\cf3 |down, repeat|\cf2  if (down && repeat.not) \{\
			pE.outline = pE.outline.not \}; \cf3 true\cf2  \});\
		drawSever.addActionChar($r, \{\cf3 |down, repeat|\cf2  if (down && repeat.not) \{\
			rCount = rCount+1; pE.refMode = rCount.mod(5) \}; \cf3 true\cf2  \});\
		drawSever.addActionChar($q, \{\cf3 |down, repeat|\cf2  if (down && repeat.not) \{\
			qCount = qCount+1; pE.quantMode = qCount.mod(pE.quantModes.size) \}; \cf3 true\cf2  \});\
		drawSever.addActionChar($a, \{\cf3 |down, repeat|\cf2  if (down && repeat.not) \{\
			aCount = aCount+1; pE.anchorMode = aCount.mod(3) \}; \cf3 true\cf2  \});\
		drawSever.addActionChar($s, \{\cf3 |down, repeat|\cf2  if (down && repeat.not) \{\
			pE.selOn = pE.selOn.not \}; \cf3 true\cf2  \});\
		drawSever.addActionChar($g, \{\cf3 |down, repeat|\cf2  if (down && repeat.not) \{\
			sysTab.mlSel.selected(0).postln \}; \cf3 true\cf2  \});\
		\cf5 // fieldActions\cf2 \
		drawSever.addActionField(pE.view.bounds, \{\cf3 |cC, mod|\cf2  \
			if ((cC > 2) && mod.isShift && mod.isAlt.not) \{ pE.refScaleY = 1; \cf3 true\cf2  \} \{ \cf3 false\cf2  \} \});\
		\cf5 // mouseMoveActions\cf2 \
		drawSever.addMouseMoveActionFields(pE.view.bounds, \{\cf3 |point, mod, mouseStart, deltaXY|\cf2 \
			if (mod.isAlt || mod.isShift.not) \{ \cf3 false\cf2  \} \{ //\cf5 this.logln("deltaXY" + deltaXY);\cf2 \
				pE.refScaleY = pE.refScaleY + ( deltaXY[1] / 1000); \cf3 true\cf2  \} \});\
			\
		pE.sysCalcs = ();\
		pE.labelHheight = pE.labelHFont.size;\
		pE.labelFheight = pE.labelFFont.size;\
		pE.drawSysYgTop = pE.yHroom + pE.labelHheight + pE.drawHGab; \cf5 // begin gab\cf2 \
		pE.drawSysYgBot = pE.yFroom + pE.labelFheight + pE.drawFGab; \cf5 // end gab\cf2 \
				\
		\{\cf3 |e, view, anchorMode octaveRanges, scaleMode, midiRef, refMode, refXGab, refYGab, refOff,\
			refFontExt, refScaleY, scale, post|\cf2  \
\cf5 //e.postOffset = 300@20;\cf2 \
			\cf5 //x\cf2 \
			e.drawWidth = view.drawBounds.width; \
			e.xMin = 0; e.xMax = e.drawWidth; e.xAddLeft = 0; e.xAddRight = 0;\
			e.offX = e.sysOffX;\
			\cf5 //y\cf2 \
			e.drawHeight = view.drawBounds.height; \
			e.yMin = 0; e.yMax = e.drawHeight; e.yAddTop = 0; e.yAddBot = 0;\
			\cf5 //SYS placing\cf2 \
			e.drawSysH = e.drawHeight - e.drawSysYgTop - e.drawSysYgBot;\
			e.yFB = e.drawSysYgTop + e.drawSysH + e.drawFGab;\
			e.drawSys0 = [\{e.drawSysYgTop + (e.drawSysH / 2)\}, \{e.drawSysYgTop + e.drawSysH\}\
				,\{e.drawSysYgTop\}][anchorMode].value;\
			\cf5 //midi scaling\cf2 \
			e.scaleMidi = e.drawSysH * refScaleY * scale[1] / (octaveRanges.clipAt(scaleMode) * 12); \
			\cf5 //default midi range\cf2 \
			e.midiMax = octaveRanges.clipAt(scaleMode) * [6, 12, 0][anchorMode]; \
			e.midiMin = octaveRanges.clipAt(scaleMode) * [-6, 0, -12][anchorMode];\
			\
post.add([\cf6 \\postln\cf2 , \cf4 "SYSTab:"\cf2  + sysTab.name + \cf4 "refScaleY:"\cf2  + e.refScaleY ++ \cf4 "; midiRef:"\cf2  + e.midiRef, 0])\
	\}\}\
\
	, \{\{\cf3 |e, drawSys0, scaleMidi, midiMin, midiMax, yAddTop, yAddBot, xAddLeft, xAddRight,\
			scaleDelta, scaledView, view, post\
			,drawWidth |\cf2 \
			\cf3 var\cf2  canvasBounds; \cf5 //canvasBounds is calculated after calcTree but before any drawing\cf2 \
\cf5 //			var scaledRect = scaledView.translateScale(scaledView.drawBounds);\cf2 \
			\cf3 var\cf2  scaledRect2 = \cf3 Rect\cf2 .new.scaleCenteredIn(scaledView.drawBounds, scaledView.keepRatio, scaledView.scale);\
			e.scaledBoundsMin = \cf3 Rect\cf2 .new.scaleCenteredIn(scaledView.drawBounds, scaledView.keepRatio, scaledView.scale, 0@0); \cf5 //if moved to 0\cf2 \
			e.scaledBoundsMax = \cf3 Rect\cf2 .new.scaleCenteredIn(scaledView.drawBounds, scaledView.keepRatio, scaledView.scale, 1@1); \cf5 //if moved to 1\cf2 \
			\
			\
			e.yMin = (drawSys0 - (midiMax * scaleMidi) - yAddTop).min(e.yMin); \cf5 // - yAddTop\cf2 \
			e.yMax = (drawSys0 - (midiMin * scaleMidi) + yAddBot).max(e.yMax);\cf5 // - + yAddBot\cf2 \
		\cf5 //testing:\cf2 \
		\cf5 //	e.xMin = e.drawWidth * -1;  // - e.xAddLeft\cf2 \
		\cf5 //	e.xMax = e.drawWidth * 2; // + e.xAddRight\cf2 \
			\
			e.canvasBounds = canvasBounds = scaledView.translateScaleX( \
				\cf3 Rect\cf2 .fromPoints(e.xMin@e.yMin, e.xMax@e.yMax).moveBy(0, scaleDelta[1]) );\
\
			\
post.add([\cf6 \\postln\cf2 , \cf4 "canvasBounds:"\cf2  + e.canvasBounds.asArray.round(0.01), 1]);\
post.add([\cf6 \\postln\cf2 , \cf4 "canvasBounds trans:"\cf2  + scaledView.translateScale(e.canvasBounds).asArray.round(0.01), 0]);\
\
post.add([\cf6 \\postln\cf2 , \cf4 "scaleCenteredIn:"\cf2  + scaledRect2.asArray.round(0.01), 1]);\
post.add([\cf6 \\postln\cf2 , \cf4 "scaledBoundsMin:"\cf2  + e.scaledBoundsMin.asArray.round(0.01), 0]);\
post.add([\cf6 \\postln\cf2 , \cf4 "scaledBoundsMax:"\cf2  + e.scaledBoundsMax.asArray.round(0.01), 0]);\
\cf5 //post.add([\\postln, "totalBounds:" + e.totalBounds.asArray.round(0.01), 0]);\cf2 \
\
			if (scaledView.canvasBounds != canvasBounds) \{ \
				\cf5 this.logln("upd canvas:" + canvasBounds, lfB:2); \cf2 \
				scaledView.canvasBounds_(canvasBounds, \cf3 false\cf2 ); \cf5 //shows next drawing only\cf2 \
			\}; \
						\
		post.add([\cf6 \\postln\cf2 , \cf4 "midiMax, midiMin:"\cf2  + [e.midiMax, e.midiMin], 0]);\
		post.add([\cf6 \\postln\cf2 , \cf4 "drawSys0, yMin, yMax:"\cf2  + [e.drawSys0, e.yMin, e.yMax], 0, 1]);\
		\
	\}\})\
);\
\
(\
\cf3 DrawDef\cf2 (\cf6 \\scaledTest\cf2 , \cf3 nil\cf2 \
	, \{\{\cf3 |e|\cf2  \
		\cf3 Color\cf2 .yellow.set; \cf3 Pen\cf2 .width = 2; \cf3 Pen\cf2 .strokeRect( e.scaledView.drawBounds.insetBy(0) );\
	\}\})\
);\
\
(\
\cf3 DrawDef\cf2 (\cf6 \\movedTest\cf2 , \cf3 nil\cf2 \
	, \{\{\cf3 |e|\cf2  \
		\cf3 Color\cf2 .white.set; \cf3 Pen\cf2 .width = 2; \cf3 Pen\cf2 .strokeRect( e.scaledView.canvasBounds.insetBy(4) );\
		\cf3 Color\cf2 .red.set; \cf3 Pen\cf2 .width = 2; \cf3 Pen\cf2 .strokeRect( e.scaledView.totalBounds.insetBy(2) );\
	\}\})\
);\
}