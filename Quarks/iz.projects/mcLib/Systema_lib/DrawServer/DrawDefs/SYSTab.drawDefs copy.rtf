{\rtf1\ansi\ansicpg1252\cocoartf1038\cocoasubrtf350
{\fonttbl\f0\fnil\fcharset0 Monaco;}
{\colortbl;\red255\green255\blue255;\red191\green0\blue0;\red0\green0\blue0;\red0\green0\blue191;
\red0\green115\blue0;\red96\green96\blue96;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural

\f0\fs18 \cf2 /*\
DrawDef.all.keys\
\
d = ScaledDrawServer.new(rate: 1, viewFollows: true).active_(true); //click in win to refresh\
DrawFunc(\\postFrameRate, target: d); \
DrawScaled(\\postFrameRate, target: d); \
\
d.active_(true)\
d.active_(false)\
*/\cf3 \
\
(\
\cf4 DrawDef\cf3 (\cf5 \\initSYSTab\cf3 ,\
	\{\cf4 |node, self, sysTab|\cf3 \
		\cf4 var\cf3  drawSever = node.tree.server;\
		\cf4 var\cf3  envir = drawSever.drawEnvir, pE = envir.parent;\
		\cf4 var\cf3  kUp, oUp, pUp, rUp, qUp, sUp, gUp, refCount, qCount;\
		kUp = oUp = pUp = rUp = qUp = sUp = gUp = \cf4 true\cf3 ;\
		\
		pE.putAll(self.envir);\
		\
		drawSever.scaleMode_(pE.scaleMode); \cf2 //also updates back into drawEnvir, but ok\cf3 \
		refCount = pE.refMode; qCount = pE.quantMode;\
		\
		\
		drawSever.addActionChar($k, \{\cf4 |down, m|\cf3  if (down.not) \{kUp = \cf4 true\cf3 \} \{\
			if (down && kUp) \{ kUp = \cf4 false\cf3 ; pE.keysOn = pE.keysOn.not \}\}; \cf4 true\cf3  \});\
		drawSever.addActionChar($o, \{\cf4 |down, m|\cf3  if (down.not) \{oUp = \cf4 true\cf3 \} \{\
			if (down && oUp) \{ oUp = \cf4 false\cf3 ; pE.outline = pE.outline.not \}\}; \cf4 true\cf3  \});\
		drawSever.addActionChar($p, \{\cf4 |down, m|\cf3  if (down.not) \{ pUp = \cf4 true\cf3  \}\{\
			if (down && pUp) \{ pUp = \cf4 false\cf3 ; pE.isPost = pE.isPost.not \}\}; \cf4 true\cf3  \});\
		drawSever.addActionChar($r, \{\cf4 |down, m|\cf3  if (down.not) \{ rUp = \cf4 true\cf3 ; \}\{\
			if (down && rUp) \{ rUp = \cf4 false\cf3 ; refCount = refCount+1; \
				pE.refMode = refCount.mod(5) \}\}; \cf4 true\cf3  \});\
		drawSever.addActionChar($q, \{\cf4 |down, m|\cf3  if (down.not) \{ qUp = \cf4 true\cf3 ; \}\{\
			if (down && qUp) \{ qUp = \cf4 false\cf3 ; qCount = qCount+1; \
				pE.quantMode = qCount.mod(pE.quantModes.size) \}\}; \cf4 true\cf3  \});\
		drawSever.addActionChar($s, \{\cf4 |down, m|\cf3  if (down.not) \{ sUp = \cf4 true\cf3  \}\{\
			if (down && sUp) \{ sUp = \cf4 false\cf3 ; pE.selOn = pE.selOn.not \}\}; \cf4 true\cf3  \});\
		drawSever.addActionChar($g, \{\cf4 |down, m|\cf3  if (down.not) \{ gUp = \cf4 true\cf3  \}\{\
			if (down && gUp) \{ gUp = \cf4 false\cf3 ; sysTab.mlSel.selected(0).postln \}\}; \cf4 true\cf3  \});\
			\
		pE.sysCalcs = ();\
		pE.labelHheight = pE.labelHFont.size; \cf2 //+ 6;\cf3 \
		pE.labelFheight = pE.labelFFont.size; \cf2 //+ 6;\cf3 \
		pE.drawSysYBG = pE.yHroom + pE.labelHheight + pE.drawHGab; \cf2 // begin gab\cf3 \
		pE.drawSysYEG = pE.yFroom + pE.labelFheight + pE.drawFGab; \cf2 // end gab\cf3 \
		\
		pE.refFontExt = \cf6 "Freq: 12342.4 "\cf3 .bounds(pE.refFont).extent;\
				\
		\{\cf4 |e, view, octaveRanges, scaleMode, midiRef, refMode, refXGab, refOff, refFontExt, post|\cf3  \
\cf2 //e.postOffset = 300@20;\cf3 \
			e.drawHeight = view.drawBounds.height;\
			e.drawWidth = view.drawBounds.width;\
			e.drawSysH = e.drawHeight - e.drawSysYBG - e.drawSysYEG;\
			e.yFB = e.drawSysYBG + e.drawSysH + e.drawFGab;\
			e.drawSysM = e.drawSysYBG + (e.drawSysH / 2); \
			e.offX = e.sysOffX; \
			\
			e.scaleMidi = octaveRanges.clipAt(scaleMode) * 12 / e.drawSysH;  \cf2 // / yS / \cf3 \
			\
			e.midiMax = octaveRanges.clipAt(scaleMode) * 6; \cf2 //for now \cf3 \
			e.midiMin = octaveRanges.clipAt(scaleMode) * -6; \cf2 //for now\cf3 \
			\
			if (refMode > 0) \{ \
				e.refOff = refFontExt.x + refXGab + refOff;\
				e.offX = e.offX + e.refOff \};\
			\
			\
post.add([\cf5 \\postln\cf3 , \cf6 "SYSTab:"\cf3  + sysTab.name + \cf6 "sysOffX:"\cf3  + e.sysOffX ++ \cf6 "; midiRef:"\cf3  + e.midiRef, 1])\
	\}\}\
\
	, \{\cf4 |node|\cf3 	\
		\{\cf4 |e, refMode, refXGab, refYGab, refFontExt, refFont, refColor, drawSysM, drawWidth, \
			octaveRanges, scaleMode, midiRef, scaleMidi, quantColors, quantModes, quantMode,\
			midiMin, midiMax, post|\cf3 \
			\cf4 var\cf3  freqFunc, midiFunc, colorFunc, gridFunc;\
			if(refMode > 0) \{\
				freqFunc = \{\cf4 |midi|\cf3  (\cf6 "Freq:"\cf3  + midi.midicps.round(0.1)) \};\
				midiFunc = \{\cf4 |midi|\cf3  (\cf6 "Midi:"\cf3  + midi.round(0.01)) \};\
				colorFunc= \{\cf4 |n|\cf3  \cf4 quantColors[\cf3 quantMode - (n.gcd( (2 ** quantMode).asInt ).log2)] \};\
				gridFunc = \{\cf4 |strFunc|\cf3 \
					\cf4 var\cf3  maxSteps = midiMax.div(quantModes[quantMode]) + 1;\
					\cf4 var\cf3  minSteps = midiMin.div(quantModes[quantMode]) * -1;\
					\cf4 var\cf3  posSteps = \cf4 Array\cf3 .series(maxSteps, 0, quantModes[quantMode])\
						.drop(1);\
					\cf4 var\cf3  negSteps = \cf4 Array\cf3 .series(minSteps, 0, quantModes[quantMode] * -1)\
						.drop(1);\
					[posSteps, negSteps].do\{\cf4 |steps|\cf3  steps.do\{\cf4 |step, i|\cf3  \cf4 var\cf3  dY = step / scaleMidi;\
						\cf4 var\cf3  color = colorFunc.value(i+1);\
						\cf4 Pen\cf3 .line(0@(drawSysM-dY) , drawWidth@(drawSysM-dY));\
						strFunc.value(midiRef + step).drawAtPoint(\
							refXGab@(drawSysM - refFontExt.y - refYGab - dY), refFont, color);\
					\}\};\
					\cf4 Pen\cf3 .stroke;\
\cf2 //					(octaveRanges.clipAt(scaleMode) * 6).asInt.do\{|i| var y = i+1 / scaleMidi;\cf3 \
\cf2 //						var color = if (i.even) \{ semiToneColor \} \{ toneColor \};\cf3 \
\cf2 //						Pen.line(0@(drawSysM-y) , drawWidth@(drawSysM -y));\cf3 \
\cf2 //						strFunc.value(midiRef + i + 1).drawAtPoint(\cf3 \
\cf2 //							refXGab@(drawSysM - refFontExt.y - refYGab - y), refFont, color);\cf3 \
\cf2 //						Pen.line(0@(drawSysM+y) , drawWidth@(drawSysM+y));\cf3 \
\cf2 //						strFunc.value(midiRef - i - 1).drawAtPoint(\cf3 \
\cf2 //							//( refXGab@(drawSysM + refYGab + y), refFont, color);\cf3 \
\cf2 //							refXGab@(drawSysM - refFontExt.y - refYGab + y), refFont, color);\cf3 \
\cf2 //						Pen.stroke \} \cf3 \
				\};\
				refColor.set; \cf4 Pen\cf3 .line(0@drawSysM, drawWidth@drawSysM); \cf4 Pen\cf3 .stroke;\
				(\cf6 "mode:"\cf3  + refMode).drawAtPoint(refXGab@refYGab, refFont, refColor);\
				refMode.switch(\
				1, \{\
					freqFunc.value(midiRef)\
					.drawAtPoint(refXGab@(drawSysM - refFontExt.y - refYGab-2), refFont, refColor);\
					midiFunc.value(midiRef)\
					.drawAtPoint(refXGab@(drawSysM + refYGab+2), refFont, refColor) \}\
				,2, \{	\
					freqFunc.value(midiRef)\
					.drawAtPoint(refXGab@(drawSysM - refFontExt.y - refYGab), refFont, refColor);\
					gridFunc.value(freqFunc) \}\
				,3, \{	\
					midiFunc.value(midiRef)\
					.drawAtPoint(refXGab@(drawSysM - refFontExt.y - refYGab), refFont, refColor);\
					gridFunc.value(midiFunc) \});\
			\}\
	\}\});\
);\
\
(\
\cf4 DrawDef\cf3 (\cf5 \\basicSYS\cf3 ,\
	\{\cf4 |node, sysSym\
		,spineWL, spineWR, ribWL, ribWR, ribEdgeWLR, ribExtL, ribExtR|\cf3 \
		\cf4 var\cf3  sysMaxL = (spineWL + ribExtL) * -1;\
		\cf4 var\cf3  sysMaxR = spineWR + ribExtR;\
		\{\cf4 |e, post, sysCalcs, sysOffX, offX|\cf3 \
			sysCalcs[sysSym] = ();\
			sysCalcs[sysSym].sys = \cf4 Systema\cf3 .at(sysSym); \cf2 // check each redraw if present!\cf3 \
			\
			\
			\
			sysCalcs[sysSym].sysMaxL = sysMaxL;\
			sysCalcs[sysSym].sysMaxR = sysMaxR;\
			sysCalcs[sysSym].sysWidth = sysMaxR - sysMaxL + 1;\
			sysCalcs[sysSym].offX = offX;\
			e.offX = offX + sysCalcs[sysSym].sysWidth + sysOffX;\
\
post.add([\cf5 \\postln\cf3 , \cf6 "SYS:"\cf3  + \cf4 SYS\cf3 .at(sysSym), 2]);\
post.add([\cf5 \\postln\cf3 , \cf6 "sysSym:"\cf3  + [sysSym, offX, e.offX], 1])\
	\}\}\
	,\{\cf4 |node, sysSym|\cf3 \
		\cf4 var\cf3  sysRect = \cf4 Rect\cf3 .new;\
		\{\cf4 |e, sysCalcs, drawSysYBG, drawSysH, post|\cf3 \
			\
			sysRect.set(sysCalcs[sysSym].offX, drawSysYBG, sysCalcs[sysSym].sysWidth, drawSysH);\
			\cf4 Color\cf3 .red.set; \cf4 Pen\cf3 .strokeRect(sysRect); \
			\
post.add([\cf5 \\postln\cf3 , \cf6 "sysCalcs:"\cf3  + [sysCalcs], 1])\
	\}\});\
);\
\
(\
\cf4 DrawDef\cf3 (\cf5 \\lableSYS\cf3 , \cf4 nil\cf3 , \
	\{\cf4 |node, sysSym, sysTab, label|\cf3 \
		\cf4 var\cf3  labelHRect = \cf4 Rect\cf3 .new; \cf2 // add to mouseDown actions...\cf3 \
		node.tree.server.addScaledActionField(labelHRect,\
			\{\cf4 |cC|\cf3  if (cC>1) \{ \cf4 SystemaTableauGui\cf3 (sysTab) \}; \cf4 true\cf3  \} );\
		\{\cf4 |e, post, sysCalcs, yHroom, labelHheight, labelHFont, labelHColor,\
			yFB, labelFheight, labelFFont, labelFColor, outline|\cf3 \
			\cf4 var\cf3  sysMaxL = sysCalcs[sysSym].sysMaxL;\
			\cf4 var\cf3  sysMaxR = sysCalcs[sysSym].sysMaxR;\
			\cf4 var\cf3  offX = sysCalcs[sysSym].offX;\
			\cf4 var\cf3  labelFRect = \cf4 Rect\cf3 (offX, yFB, sysCalcs[sysSym].sysWidth, labelFheight );\
			labelHRect.set(offX, yHroom, sysCalcs[sysSym].sysWidth, labelHheight);\
\cf2 // cannot use translate here: labelHRect must be shifted in pos for click...\cf3 \
			\cf4 Color\cf3 .black.set; \cf4 Pen\cf3 .addRect(labelHRect); \cf4 Pen\cf3 .fill;\
			if (label.bounds(labelHFont).width > labelHRect.width) \{\
				label.drawInRect(labelHRect, labelHFont, labelHColor)\
			\}\{\
				label.drawCenteredIn(labelHRect, labelHFont, labelHColor)\
			\};\
			if (label.bounds(labelFFont).width > labelFRect.width) \{\
				label.drawInRect(labelFRect, labelFFont, labelFColor)\
			\}\{\
				label.drawCenteredIn(labelFRect, labelFFont, labelFColor)\
			\};\
			if (outline) \{ \cf2 // Pen.width = 2;\cf3 \
				labelHColor.set; \cf4 Pen\cf3 .strokeRect( labelHRect );\
				labelFColor.set; \cf4 Pen\cf3 .strokeRect( labelFRect );\
			\};\
			\
post.add([\cf5 \\postln\cf3 , \cf6 "lableSYS labelHRect:"\cf3  + [labelHRect, offX, sysSym]])\
	\}\});\
);	\
\
(\
\cf4 DrawDef\cf3 (\cf5 \\instAnno\cf3 ,\
	\{\cf4 |node, align|\cf3 \
		\{\cf4 |e, post|\cf3  \
				\
post.add([\cf5 \\postln\cf3 , \cf6 "instAnno align:"\cf3  + align])\
	\}\}\
	, \{\cf4 |node, align|\cf3 \
		\{\cf4 |e, post|\cf3  \
				\
post.add([\cf5 \\postln\cf3 , \cf6 "node, align:"\cf3  + [node, align]])\
	\}\});\
);\
\
(\
\cf4 DrawDef\cf3 (\cf5 \\vocAnno\cf3 ,\
	\{\cf4 |node, align|\cf3 \
		\{\cf4 |e, post|\cf3  \
			\
post.add([\cf5 \\postln\cf3 , \cf6 "vocAnno align:"\cf3  + align])\
	\}\}\
	, \{\cf4 |node, align|\cf3 \
		\{\cf4 |e, post|\cf3  \
\
post.add([\cf5 \\postln\cf3 , \cf6 "node, align:"\cf3  + [node, align]])\
	\}\})\
);\
\
(\
\cf4 DrawDef\cf3 (\cf5 \\keysLegend\cf3 , \cf4 nil\cf3 \
	, \{\cf4 |node|\cf3 \
		\cf4 var\cf3  displayRect, strH;\
		\{\cf4 |e, view, keysOn, labelHFont, labelHColor, annoFont, post|\cf3  \
			if (keysOn) \{\
				displayRect = view.drawBounds.insetBy(70);\
				strH = \cf6 "A"\cf3 .bounds(labelHFont).height;\
				\cf4 Color\cf3 .grey.set; \cf4 Pen\cf3 .fillRect(displayRect); \cf4 Color\cf3 .white.set; \
				\cf4 Pen\cf3 .width = 4; \cf4 Pen\cf3 .strokeRect( view.drawBounds.insetBy(50) );\
				\cf4 Pen\cf3 .width = 2 ;\cf4 Pen\cf3 .strokeRect( displayRect );\
				\cf6 "Keys legend:"\cf3 .drawInRect(displayRect.insetBy(8, 10), labelHFont, labelHColor);\
				[\cf6 "k -- <on/of> -- \\t show this legend"\cf3 \
				,\cf6 "0..9 <mode>  -- \\t change Y-resolution of display"\cf3 \
				,\cf6 "r -- <mode>  -- \\t draw midi/freq reference lines"\cf3 \
				,\cf6 "q -- <mode>  -- \\t cycle quantisation of reference lines (1, 1/2, 1/4 tone)"\cf3 \
				,\cf6 "s -- <on/of> -- \\t show selected objects"\cf3 \
				,\cf6 "g -- <on/of> -- \\t grid lines of intervals of currently selected object"\cf3 \
				,\cf6 ""\cf3 \
				,\cf6 "F -- <on/of> -- \\t full screen mode"\cf3 \
				,\cf6 ""\cf3 \
				,\cf6 "o -- <on/of> -- \\t draw outlines of objects"\cf3 \
				,\cf6 "p -- <on/of> -- \\t debug posts"\cf3 \
				].do\{\cf4 |str, i|\cf3  str.drawInRect(\
					displayRect.insetBy(8, 40 + (i*strH)), labelHFont, labelHColor)\};\
			\};	\
post.add([\cf5 \\postln\cf3 , \cf6 "keysOn:"\cf3  + [keysOn]])\
	\}\});\
);}