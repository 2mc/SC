{\rtf1\ansi\ansicpg1252\cocoartf1038\cocoasubrtf350
{\fonttbl\f0\fnil\fcharset0 Monaco;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;\red0\green0\blue191;\red96\green96\blue96;
\red0\green115\blue0;\red191\green0\blue0;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural

\f0\fs18 \cf2 if (\cf3 this\cf2 .isLog(2)) \{ (\cf4 "\\n\\n"\cf2  + \cf3 thisProcess\cf2 .nowExecutingPath.basename + \cf4 "\\n"\cf2 ).postln; \};\
\
(\
\cf3 DrawDef\cf2 (\cf5 \\lineY\cf2 , \cf5 \\draw\cf2 , \cf3 nil\cf2 \
	, \{\cf3 |node, pE, y=100, dashArray, color|\cf2 \
		pE.yNewMidiRef = y;\
		pE.newMidiRefFloatArray = dashArray; \cf6 // make it an unique accessible var\cf2 \
		pE.newMidiRefColor = color ?? \{ \cf3 Color\cf2 .yellow \};\
		\{\cf3 |e, drawWidth, yNewMidiRef, newMidiRefFloatArray, newMidiRefColor|\cf2 \
		\cf3 Pen\cf2 .use\{ \
			if (newMidiRefFloatArray.notNil) \{ \cf3 Pen\cf2 .lineDash_(newMidiRefFloatArray) \};\
			newMidiRefColor.set; \
			\cf3 Pen\cf2 .width = 1.5; \cf3 Pen\cf2 .line(0@yNewMidiRef, drawWidth@yNewMidiRef); \cf3 Pen\cf2 .stroke;\
		\}\}\})\
);\
\
(\
\cf3 DrawDef\cf2 (\cf5 \\SYSTab_RefLinesBefore\cf2 , \cf5 \\moved\cf2 ,\
	\{\cf3 |node, drawServer, sysTab, pE, e|\cf2 \
		\cf6 //all sysTab params already put into pE by DrawDef 'SYSTab_init'\cf2 \
		\cf3 var\cf2  rCount, qCount, prevRefSysSym, refSys, refSysUpdFunc, refSysDepFunc;\
		pE.refSysSym = prevRefSysSym = pE.refSysSym ?? \{ sysTab.sysSymbols.first \};\
		pE.refFontExt = \cf4 "Freq: 12342.4 "\cf2 .bounds(pE.refFont).extent;\
		\
		\cf6 // keyActions\cf2 \
		rCount = pE.refMode; qCount = pE.quantMode;\
		\
		drawServer.addActionChar($r, \{\cf3 |down, repeat|\cf2  if (down && repeat.not) \{\
			rCount = rCount+1; pE.refMode = rCount.mod(5) \}; \cf3 true\cf2  \});\
		drawServer.addActionChar($R, \{\cf3 |down, repeat|\cf2  if (down && repeat.not) \{\
			rCount = rCount-1; pE.refMode = rCount.mod(5) \}; \cf3 true\cf2  \});\
		drawServer.addActionChar($q, \{\cf3 |down, repeat|\cf2  if (down && repeat.not) \{\
			qCount = qCount+1; pE.quantMode = qCount.mod(pE.quantModes.size) \}; \cf3 true\cf2  \});\
		drawServer.addActionChar($Q, \{\cf3 |down, repeat|\cf2  if (down && repeat.not) \{\
			qCount = qCount-1; pE.quantMode = qCount.mod(pE.quantModes.size) \}; \cf3 true\cf2  \});\
		drawServer.addActionChar($g, \{\cf3 |down, repeat|\cf2  if (down && repeat.not) \{\
			pE.gridOn = pE.gridOn.not \}; \cf3 true\cf2  \});\
		drawServer.addActionChar($y, \{\cf3 |down, repeat|\cf2  if (down && repeat.not) \{\
			sysTab.mlSel.selected(0).postln \}; \cf3 true\cf2  \});\
		\
		\cf6 //action fields\cf2 \
		pE.refMidiRect = \cf3 Rect\cf2 .new;\
		drawServer.addField(\cf3 MovedDeltaActionField\cf2 , pE.refMidiRect, \{\cf3 |sV, cC, mod|\cf2 \
				mod.switch(\
					262401, \{ \cf3 DrawFunc\cf2 (\cf5 \\lineY\cf2 , (pE: pE, yNewMidiRef: 400), node, 0) \} \cf6 // ctrl\cf2 \
					,393475, \{ \cf3 DrawFunc\cf2 (\cf5 \\lineY\cf2 , (pE: pE,\
						yNewMidiRef: 200, newMidiRefFloatArray: \cf3 FloatArray\cf2 [3,3]\
						), node)  \} \cf6 // shift-ctrl\cf2 \
					,786721, \{ \cf3 false\cf2  \} \cf6 // ctrl-alt\cf2 \
					,917795, \{ \cf3 false\cf2  \} \cf6 // shift-ctrl-alt\cf2 \
					, \{\cf3 false\cf2 \} )\
			\},\{\cf3 |sV, fwdArgs, mod, cP, p, deltaXY|\cf2 \
				mod.switch(\
					262401, \{ pE.newMidiRefFloatArray = \cf3 FloatArray\cf2 [1,0] ; fwdArgs\} \cf6 // ctrl\cf2 \
					,393475, \{ pE.newMidiRefFloatArray = \cf3 FloatArray\cf2 [5,5]; fwdArgs\} ); \cf6 // shift-ctrl\cf2 \
				fwdArgs \cf6 // foreward the fwdArgs once more!\cf2 \
			\},\{\cf3 |sV, fwdArgs, mod, cP, p|\cf2 \
				\cf3 var\cf2  newRef = pE.y2midiFunc(p.y);\
				\cf3 this\cf2 .logln(\cf4 "stopped at:"\cf2  + [cP, p]);\
				pE.midiRef = newRef;\
				\cf3 this\cf2 .logln(\cf4 "fwdArgs:"\cf2  + fwdArgs);\
				if (fwdArgs.isKindOf(\cf3 FuncNode\cf2 )) \{ fwdArgs.remove \};\
		\});\
		\
		\cf6 // reused funcs\cf2 \
		pE.refMidiNotesFunc = \{\cf3 |pE|\cf2  \
			\cf3 var\cf2  div, maxSteps, minSteps, negSteps, posSteps;\
			\cf3 var\cf2  quant = pE.quantModes[pE.quantMode];\
			div = e.midiMax / quant;\
			maxSteps = div.round(1).asInt + 2;\
			if (div.frac < (quant/2)) \{maxSteps = maxSteps - 1\};\
			div =  e.midiMin * -1 / quant;\
			minSteps = div.round(1).asInt + 2;\
			if (div.frac < (quant/2) ) \{minSteps = minSteps - 1\};\
			posSteps = \cf3 Array\cf2 .series(maxSteps, 0, quant);\
			negSteps = \cf3 Array\cf2 .series(minSteps, 0, quant * -1);\
			negSteps.reverse ++ posSteps \};\
		pE.refColorFunc =  \{\cf3 |pE, n|\cf2 \
			pE.quantColors[pE.quantMode - (n.gcd( (2 ** pE.quantMode).asInt ).log2)] \};\
		pE.refGridFunc = \{\cf3 |pE, yS, colors, lineWidth|\cf2 \
			yS.do\{\cf3 |y, i|\cf2  colors[i].setStroke; \cf3 Pen\cf2 .line(0@y, lineWidth@y); \cf3 Pen\cf2 .stroke \} \};\
		\
		\cf6 //refSys support\cf2 \
		refSysUpdFunc = \{\
			pE.refSysMidiNotes = e.sysMidiNotesFunc(refSys);\
			pE.refSysColors = e.sysStepColorsFunc(refSys) \};\
		refSysDepFunc = \{\cf3 |who, what|\cf2  refSysUpdFunc.value \}; \cf6 //any change need recalc anyway\cf2 \
		node.addDependantFuncTo(\cf3 Systema\cf2 , \{\cf3 |who, what, name|\cf2  \cf6 //this.logln("sCD:" + [who, what, name]);\cf2 \
			what.switch(\
				\cf5 \\new\cf2 , \{ if (name == pE.refSysSym) \{ \
					refSys = \cf3 Systema\cf2 .at(name); refSysUpdFunc.value; \
					node.addDependantFuncTo(refSys, refSysDepFunc) \}\'a0\}\
				,\cf5 \\destroy\cf2 , \{ refSys = \cf3 nil\cf2 ; pE.refSysMidiNotes = []; pE.refSysColors = [] \} ) \} );\
		refSys = \cf3 Systema\cf2 .at(prevRefSysSym); \cf6 //check only once;\cf2 \
		if (refSys.isNil) \{ pE.refSysMidiNotes = []; pE.refSysColors = []\
		\}\{ refSysUpdFunc.value; node.addDependantFuncTo(refSys, refSysDepFunc) \};\
\
		\
		\{\cf3 |e, refMode, refFontExt, refXOff, refXGab, refSysSym|\cf2 \
			if (refMode > 0) \{ \
				e.refSumXOff = refFontExt.x + refXGab + refXOff;\
				e.offX = e.offX + e.refSumXOff;\
				if (refMode == 4) \{\
					if (prevRefSysSym != refSysSym) \{\
						prevRefSysSym = refSysSym;\
						node.removeDependantFunc(refSysDepFunc); \cf6 // nil ok here!\cf2 \
						refSys = \cf3 Systema\cf2 .at(refSysSym);\
						refSys !? \{\'a0refSysUpdFunc.value;\
							node.addDependantFuncTo(refSys, refSysDepFunc) \};\
			\}\}\}\
	\}\}\
	,\{\{\cf3 |e, refMode, gridOn, refXGab, refColor, drawSys0, drawWidth, trans, scaleDelta, refMidiRect,\
		refSysMidiNotes, refSysColors, outline, selHeight=10|\cf2 \
		if(refMode > 0) \{\
			if (refMode == 4) \{\
				e.refMidiNotes = refSysMidiNotes;\
				e.refColors = refSysColors;\
			\}\{ \
				e.refMidiNotes = e.refMidiNotesFunc;\
				e.refColors = e.refMidiNotes.collect\{\cf3 |mn, i|\cf2  e.refColorFunc(i+1) \}\
			\};\
			e.refYs = e.refMidiNotes.collect\{\cf3 |midinote|\cf2  e.midi2yFunc(midinote) \};\
\
			if(gridOn) \{\
				refMidiRect.set(0, drawSys0 - (selHeight / 2), drawWidth, selHeight);		\
				\cf3 Pen\cf2 .use\{ \cf3 Pen\cf2 .translate(trans[0], scaleDelta[1]);\
					\cf3 Pen\cf2 .width = 1;\
					if (refMode > 1) \{ e.refGridFunc(e.refYs, e.refColors, drawWidth) \};\
					refColor.setStroke; \cf3 Pen\cf2 .line(0@drawSys0, drawWidth@drawSys0); \cf3 Pen\cf2 .stroke;\
					if (outline) \{ \cf3 Color\cf2 .grey.setStroke; \cf3 Pen\cf2 .strokeRect(refMidiRect) \}\
				\}\
			\}\{ refMidiRect.set(0,0,0,0) \};\
		\} \{ refMidiRect.set(0,0,0,0) \}; \
	\}\})\
);\
\
(\
\cf3 DrawDef\cf2 (\cf5 \\SYSTab_RefLinesAfter\cf2 , \cf5 \\moved\cf2 , \cf3 nil\cf2 ,\
	\{\cf3 |node, refYGab, refXGab, refFont, e|\cf2 \
		\cf3 var\cf2  refStrFreqFunc = \{\cf3 |midi|\cf2  (\cf4 "Freq:"\cf2  + midi.midicps.round(0.1)) \};\
		\cf3 var\cf2  refStrMidiFunc = \{\cf3 |midi|\cf2  (\cf4 "Midi:"\cf2  + midi.round(0.01)) \};\
		\cf3 var\cf2  refDrawStrFunc = \{\cf3 |yS, colors, midinotes, strFunc|\cf2 \
			\cf3 var\cf2  strYdelta = e.refFontExt.y + refYGab;\
			\cf3 var\cf2  midiRef = e.midiRef;\
			yS.do\{\cf3 |y, i|\cf2  strFunc.value(midiRef + midinotes[i]).drawAtPoint(\
				refXGab@(y - strYdelta), refFont, colors[i]) \};\
			e.refYmin = yS.last - strYdelta;  e.refYmax = yS.first \};\
		\
		\{\cf3 |e, refMode, refXGab, refYGab, refFontExt, refFont, refColor, refBackColor, drawSys0,\
			midiRef, drawHeight, trans, scaleDelta, refSumXOff, refYs, refColors, refMidiNotes|\cf2 \
			\
			if(refMode > 0) \{\
				\cf3 Pen\cf2 .use\{ \cf3 Pen\cf2 .translate(*trans); refBackColor.setFill; \
					\cf3 Pen\cf2 .fillRect( \cf3 Rect\cf2 .fromPoints(0@0, refSumXOff@drawHeight) );\
				\};\
				\cf3 Pen\cf2 .use\{ \cf3 Pen\cf2 .translate(trans[0], scaleDelta[1]);\
					\cf3 Pen\cf2 .width = 1; \
					refMode.switch(\
					1, \{\
						refStrFreqFunc.value(midiRef).drawAtPoint(\
							refXGab@(drawSys0 - refFontExt.y - refYGab-2), refFont, refColor);\
						refStrMidiFunc.value(midiRef).drawAtPoint(\
							refXGab@(drawSys0 + refYGab+2), refFont, refColor) \}\
					,2, \{	\
						refStrFreqFunc.value(midiRef).drawAtPoint(\
							refXGab@(drawSys0 - refFontExt.y - refYGab), refFont, refColor);\
						e.refGridFunc(refYs, refColors, refSumXOff);\
						refDrawStrFunc.value(refYs, refColors, refMidiNotes, refStrFreqFunc) \}\
					,3, \{	\
						refStrMidiFunc.value(midiRef).drawAtPoint(\
							refXGab@(drawSys0 - refFontExt.y - refYGab), refFont, refColor);\
						e.refGridFunc(refYs, refColors, refSumXOff);\
						refDrawStrFunc.value(refYs, refColors, refMidiNotes, refStrMidiFunc) \}\
					);\
					refColor.set; \cf3 Pen\cf2 .line(0@drawSys0, refSumXOff@drawSys0); \cf3 Pen\cf2 .stroke;\
				\};\
\
			\}\
	\}\})\
);\
}