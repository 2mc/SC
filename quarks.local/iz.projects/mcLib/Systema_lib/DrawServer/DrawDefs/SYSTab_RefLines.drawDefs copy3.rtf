{\rtf1\ansi\ansicpg1252\cocoartf1038\cocoasubrtf350
{\fonttbl\f0\fnil\fcharset0 Monaco;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue191;\red96\green96\blue96;\red0\green0\blue0;
\red0\green0\blue191;\red0\green115\blue0;\red191\green0\blue0;\red96\green96\blue96;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural

\f0\fs18 \cf0 if (\cf2 this\cf0 .isLog(2)) \{ (\cf3 "\\n\\n"\cf0  + \cf2 thisProcess\cf0 .nowExecutingPath.basename + \cf3 "\\n"\cf0 ).postln; \};\
\cf4 \
(\
\cf5 DrawDef\cf4 (\cf6 \\lineY\cf4 , \cf6 \\draw\cf4 , \cf5 nil\cf4 \
	, \{\cf5 |node, pE, y=100, dashArray, color|\cf4 \
		pE.yNewMidiRef = y;\
		pE.newMidiRefFloatArray = dashArray; \cf7 // make it an unique accessible var\cf4 \
		pE.newMidiRefColor = color ?? \{ \cf5 Color\cf4 .yellow \};\
		\{\cf5 |e, drawWidth, yNewMidiRef, newMidiRefFloatArray, newMidiRefColor|\cf4 \
		\cf5 Pen\cf4 .use\{ \
			if (newMidiRefFloatArray.notNil) \{ \cf5 Pen\cf4 .lineDash_(newMidiRefFloatArray) \};\
			newMidiRefColor.set; \
			\cf5 Pen\cf4 .width = 1.5; \cf5 Pen\cf4 .line(0@yNewMidiRef, drawWidth@yNewMidiRef); \cf5 Pen\cf4 .stroke;\
		\}\}\})\
);\
\
(\
\cf5 DrawDef\cf4 (\cf6 \\SYSTab_RefLinesBefore\cf4 , \cf6 \\moved\cf4 ,\
	\{\cf5 |node, drawServer, sysTab, pE|\cf4  \cf7 //all sysTab params already put into pE by DrawDef 'SYSTab_init'\cf4 \
		\cf5 var\cf4  rCount, qCount;\
		\cf5 var\cf4  refFontExt;\
		pE.refFontExt = refFontExt = \cf8 "Freq: 12342.4 "\cf4 .bounds(pE.refFont).extent;\
		\
		\cf7 // keyActions\cf4 \
		rCount = pE.refMode; qCount = pE.quantMode;\
		\
		drawServer.addActionChar($r, \{\cf5 |down, repeat|\cf4  if (down && repeat.not) \{\
			rCount = rCount+1; pE.refMode = rCount.mod(5) \}; \cf5 true\cf4  \});\
		drawServer.addActionChar($R, \{\cf5 |down, repeat|\cf4  if (down && repeat.not) \{\
			rCount = rCount-1; pE.refMode = rCount.mod(5) \}; \cf5 true\cf4  \});\
		drawServer.addActionChar($q, \{\cf5 |down, repeat|\cf4  if (down && repeat.not) \{\
			qCount = qCount+1; pE.quantMode = qCount.mod(pE.quantModes.size) \}; \cf5 true\cf4  \});\
		drawServer.addActionChar($Q, \{\cf5 |down, repeat|\cf4  if (down && repeat.not) \{\
			qCount = qCount-1; pE.quantMode = qCount.mod(pE.quantModes.size) \}; \cf5 true\cf4  \});\
		drawServer.addActionChar($g, \{\cf5 |down, repeat|\cf4  if (down && repeat.not) \{\
			pE.gridOn = pE.gridOn.not \}; \cf5 true\cf4  \});\
		drawServer.addActionChar($y, \{\cf5 |down, repeat|\cf4  if (down && repeat.not) \{\
			sysTab.mlSel.selected(0).postln \}; \cf5 true\cf4  \});\
		\
		pE.midiRefRect = \cf5 Rect\cf4 .new;\
		drawServer.addField(\cf5 MovedDeltaActionField\cf4 , pE.midiRefRect, \{\cf5 |sV, cC, mod|\cf4 \
				mod.switch(\
					262401, \{ \cf5 DrawFunc\cf4 (\cf6 \\lineY\cf4 , (pE: pE, yNewMidiRef: 400), node, 0) \} \cf7 // ctrl\cf4 \
					,393475, \{ \cf5 DrawFunc\cf4 (\cf6 \\lineY\cf4 , (pE: pE,\
						yNewMidiRef: 200, newMidiRefFloatArray: \cf5 FloatArray\cf4 [3,3]\
						), node)  \} \cf7 // shift-ctrl\cf4 \
					,786721, \{ \cf5 false\cf4  \} \cf7 // ctrl-alt\cf4 \
					,917795, \{ \cf5 false\cf4  \} \cf7 // shift-ctrl-alt\cf4 \
					, \{\cf5 false\cf4 \} )\
			\},\{\cf5 |sV, fwdArgs, mod, cP, p, deltaXY|\cf4 \
				mod.switch(\
					262401, \{ pE.newMidiRefFloatArray = \cf5 FloatArray\cf4 [1,0] ; fwdArgs\} \cf7 // ctrl\cf4 \
					,393475, \{ pE.newMidiRefFloatArray = \cf5 FloatArray\cf4 [5,5]; fwdArgs\} ); \cf7 // shift-ctrl\cf4 \
				fwdArgs \cf7 // foreward the fwdArgs once more!\cf4 \
			\},\{\cf5 |sV, fwdArgs, mod, cP, p|\cf4 \
				\cf5 var\cf4  newRef = pE.y2midiFunc(p.y);\
				\cf5 this\cf4 .logln(\cf8 "stopped at:"\cf4  + [cP, p]);\
				pE.midiRef = newRef;\
				\cf5 this\cf4 .logln(\cf8 "fwdArgs:"\cf4  + fwdArgs);\
				if (fwdArgs.isKindOf(\cf5 FuncNode\cf4 )) \{ fwdArgs.remove \};\
		\});\
		\
		\
		\
		\
		\{\cf5 |e, refMode, refXOff, refXGab, refYGab, refScaleY, yAddTop|\cf4 \
			if (refMode > 0) \{ \
				e.refSumXOff = refFontExt.x + refXGab + refXOff;\
				e.offX = e.offX + e.refSumXOff \}\
	\}\}\
	,\{\{\cf5 |e, refMode, gridOn, refXGab, refYGab, refFontExt, refFont, refColor, refBackColor, drawSys0,\
			drawWidth, midiRef, midiScale, quantColors, quantModes, quantMode, midiMin, midiMax,\
			drawHeight, trans, scale, scaleDelta, scaledView, midiRefRect, outline, selHeight=10|\cf4 \
			\cf5 var\cf4  colorFunc, gridFunc;\
			if(refMode > 0) \{\
				e.colorFunc = colorFunc =  \{\cf5 |n|\cf4  \
					quantColors[quantMode - (n.gcd( (2 ** quantMode).asInt ).log2)] \};\
				e.gridFunc = gridFunc = \{\cf5 |lineWidth, strFunc|\cf4 \
				\cf5 var\cf4  steps, yS;\
					\cf5 var\cf4  div, maxSteps, minSteps, negSteps, posSteps, y, strYdelta;\
					\cf5 var\cf4  quant = quantModes[quantMode];\
					div = midiMax / quant;\
					maxSteps = div.round(1).asInt + 2;\
					if (div.frac < (quant/2)) \{maxSteps = maxSteps - 1\};\
					div =  midiMin * -1 / quant;\
					minSteps = div.round(1).asInt + 2;\
					if (div.frac < (quant/2) ) \{minSteps = minSteps - 1\};\
					posSteps = \cf5 Array\cf4 .series(maxSteps, 0, quant);\
					negSteps = \cf5 Array\cf4 .series(minSteps, 0, quant * -1);\
					\
					steps = negSteps.reverse ++ posSteps;\
					yS = \cf0 steps * e.midiScale * e.scale[1] + (e.drawSys0 * -1);\cf4 \
					\
					yS.postln;\
					\
					strFunc !? \{strYdelta = drawSys0 - refFontExt.y - refYGab \};\
					\
					steps.do\{\cf5 |step, i|\cf4  \
						\cf5 var\cf4  dY = step * midiScale * scale[1];\
						\cf5 var\cf4  color = colorFunc.value(i+1).setStroke;\
						y = drawSys0-dY;\
						\cf5 Pen\cf4 .line(0@y , lineWidth@y); \cf5 Pen\cf4 .stroke;\
						strFunc !? \{ y = strYdelta - dY;\
							strFunc.value(midiRef + step).drawAtPoint(\
								refXGab@y, refFont, color) \};\
					\};\
					strFunc !? \{ \
						e.refYmin = drawSys0 - refFontExt.y - refYGab - \
							(steps.last * midiScale * scale[1]);\
						e.refYmax = drawSys0 - (steps.first * midiScale * scale[1])\
					\};\
				\};\
				\
				if(gridOn) \{\
					midiRefRect.set(0, drawSys0 - (selHeight / 2), drawWidth, selHeight);		\
					\cf5 Pen\cf4 .use\{ \cf5 Pen\cf4 .translate(trans[0], scaleDelta[1]);\
						\cf5 Pen\cf4 .width = 1;\
						refMode.switch(\
							2, 	\{ gridFunc.value(drawWidth) \}\
							,3,	\{ gridFunc.value(drawWidth) \}\
							,4,	\{ gridFunc.value(drawWidth) \});\
						refColor.setStroke; \cf5 Pen\cf4 .line(0@drawSys0, drawWidth@drawSys0); \cf5 Pen\cf4 .stroke;\
						if (outline) \{ \cf5 Color\cf4 .grey.setStroke; \cf5 Pen\cf4 .strokeRect(midiRefRect) \}\
					\}\
				\}\{ midiRefRect.set(0,0,0,0) \};\
			\} \{ midiRefRect.set(0,0,0,0) \}; \
	\}\})\
);\
\
(\
\cf5 DrawDef\cf4 (\cf6 \\SYSTab_RefLinesAfter\cf4 , \cf6 \\moved\cf4 , \cf5 nil\cf4 ,\
	\{\cf5 |node|\cf4 \
		\cf5 var\cf4  freqFunc = \{\cf5 |midi|\cf4  (\cf8 "Freq:"\cf4  + midi.midicps.round(0.1)) \};\
		\cf5 var\cf4  midiFunc = \{\cf5 |midi|\cf4  (\cf8 "Midi:"\cf4  + midi.round(0.01)) \};\
		\{\cf5 |e, refMode, refXGab, refYGab, refFontExt, refFont, refColor, refBackColor, drawSys0,\
			midiRef, drawHeight, trans, scaleDelta, colorFunc, gridFunc, refSumXOff|\cf4 \
			if(refMode > 0) \{\
				\cf5 Pen\cf4 .use\{ \cf5 Pen\cf4 .translate(*trans); refBackColor.setFill; \
					\cf5 Pen\cf4 .fillRect( \cf5 Rect\cf4 .fromPoints(0@0, refSumXOff@drawHeight) );\
					\cf7 //("mode:" + refMode).drawAtPoint(refXGab@refYGab, refFont, refColor);\cf4 \
				\};\
				\
				\cf5 Pen\cf4 .use\{ \cf5 Pen\cf4 .translate(trans[0], scaleDelta[1]);\
					\cf5 Pen\cf4 .width = 1; \
					refMode.switch(\
					1, \{\
						freqFunc.value(midiRef)\
						.drawAtPoint(refXGab\
							@(drawSys0 - refFontExt.y - refYGab-2), refFont, refColor);\
						midiFunc.value(midiRef)\
						.drawAtPoint(refXGab\
							@(drawSys0 + refYGab+2), refFont, refColor) \}\
					,2, \{	\
						freqFunc.value(midiRef)\
						.drawAtPoint(refXGab\
							@(drawSys0 - refFontExt.y - refYGab), refFont, refColor);\
						gridFunc.value(refSumXOff, freqFunc) \}\
					,3, \{	\
						midiFunc.value(midiRef)\
						.drawAtPoint(refXGab\
							@(drawSys0 - refFontExt.y - refYGab), refFont, refColor);\
						gridFunc.value(refSumXOff, midiFunc) \});\
					refColor.set; \cf5 Pen\cf4 .line(0@drawSys0, refSumXOff@drawSys0); \cf5 Pen\cf4 .stroke;\
				\};\
\
			\}\
	\}\})\
);\
}